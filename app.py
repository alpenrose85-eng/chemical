import streamlit as st
import pandas as pd
from docx import Document
import re
import io
from docx.oxml.ns import qn
from docx.oxml import OxmlElement
from docx.shared import Pt

# –ù–æ—Ä–º—ã –¥–ª—è —Å—Ç–∞–ª–µ–π
NORMS = {
    "12–•1–ú–§": {
        "C": (0.10, 0.15),
        "Si": (0.17, 0.27),
        "Mn": (0.40, 0.70),
        "Cr": (0.90, 1.20),
        "Ni": (None, 0.25),
        "Mo": (0.25, 0.35),
        "V": (0.15, 0.30),
        "Cu": (None, 0.20),
        "S": (None, 0.025),
        "P": (None, 0.025)
    },
    "12–•18–ù12–¢": {
        "C": (None, 0.12),
        "Si": (None, 0.80),
        "Mn": (1.00, 2.00),
        "Cr": (17.00, 19.00),
        "Ni": (11.00, 13.00),
        "Ti": (None, 0.7),
        "Cu": (None, 0.30),
        "S": (None, 0.020),
        "P": (None, 0.035)
    }
}

# –≠–ª–µ–º–µ–Ω—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Ç–∞–ª–∏
ELEMENTS_BY_STEEL = {
    "12–•1–ú–§": ["C", "Si", "Mn", "Cr", "Ni", "Mo", "V", "Cu", "S", "P"],
    "12–•18–ù12–¢": ["C", "Si", "Mn", "Cr", "Ni", "Ti", "Cu", "S", "P"]
}

def parse_protocol_docx(file):
# ================================
# –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è parse_protocol_docx
# ================================

from docx.oxml.text.paragraph import CT_P
from docx.oxml.table import CT_Tbl
from docx.text.paragraph import Paragraph
from docx.table import Table
from docx.document import Document as DocxDocumentClass

def iter_block_items(parent):
    """–ò—Ç–µ—Ä–∞—Ç–æ—Ä –ø–æ —ç–ª–µ–º–µ–Ω—Ç–∞–º –¥–æ–∫—É–º–µ–Ω—Ç–∞ (–ø–∞—Ä–∞–≥—Ä–∞—Ñ—ã –∏ —Ç–∞–±–ª–∏—Ü—ã –≤ –ø–æ—Ä—è–¥–∫–µ —Å–ª–µ–¥–æ–≤–∞–Ω–∏—è)."""
    if isinstance(parent, DocxDocumentClass):
        parent_elm = parent.element.body
    else:
        raise ValueError("parent must be a Document instance")
    for child in parent_elm.iterchildren():
        if isinstance(child, CT_P):
            yield Paragraph(child, parent)
        elif isinstance(child, CT_Tbl):
            yield Table(child, parent)

def extract_means_from_table(table):
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Å—Ä–µ–¥–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –æ–¥–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã."""
    means = {}
    headers = []

    for i, row in enumerate(table.rows):
        first_cell = row.cells[0].text.strip()
        first_cell_clean = re.sub(r'\s+', ' ', first_cell).strip()

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏: —Å—Ç—Ä–æ–∫–∞, –≥–¥–µ –ø–µ—Ä–≤–∞—è —è—á–µ–π–∫–∞ –ø—É—Å—Ç–∞—è, –∞ –æ—Å—Ç–∞–ª—å–Ω—ã–µ ‚Äî –±—É–∫–≤—ã
        if not first_cell_clean or first_cell_clean == "-":
            headers = []
            for cell in row.cells[1:]:
                h = re.sub(r'\s+', ' ', cell.text).replace('%', '').strip()
                if h and not h.replace('.', '').replace(',', '').isdigit() and not h.startswith(('¬±', '1', '2', '3', '–°—Ä–µ–¥–Ω–µ–µ')):
                    headers.append(h)

        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å—Ç—Ä–æ–∫—É "–°—Ä–µ–¥–Ω–µ–µ:" (–Ω–æ –Ω–µ –ø–æ–≥—Ä–µ—à–Ω–æ—Å—Ç–∏)
        if "–°—Ä–µ–¥–Ω–µ–µ:" in first_cell_clean and not first_cell_clean.startswith("–°—Ä–µ–¥–Ω–µ–µ: ¬±"):
            for j, cell in enumerate(row.cells[1:], start=0):
                val_text = re.sub(r'\s+', ' ', cell.text).strip()
                if val_text and not val_text.startswith(('¬±', '-')) and j < len(headers):
                    try:
                        val = float(val_text.replace(',', '.'))
                        elem = headers[j]
                        means[elem] = val
                    except ValueError:
                        continue
    return means

def parse_protocol_docx(file):
    doc = Document(file)
    samples = []
    current_sample_name = None
    current_steel = None
    table_buffer = []  # –ë—É—Ñ–µ—Ä –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü —Ç–µ–∫—É—â–µ–≥–æ –æ–±—Ä–∞–∑—Ü–∞

    for block in iter_block_items(doc):
        if isinstance(block, Paragraph):
            para_text = block.text.strip()
            if "–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞–∑—Ü–∞ :" in para_text:
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –æ–±—Ä–∞–∑–µ—Ü, –µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ
                if current_sample_name and len(table_buffer) >= 2:
                    means1 = extract_means_from_table(table_buffer[0])
                    means2 = extract_means_from_table(table_buffer[1])
                    all_means = {**means1, **means2}
                    notes = "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π" if "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π" in para_text else ""
                    samples.append({
                        "name": current_sample_name,
                        "steel": current_steel,
                        "elements": all_means,
                        "notes": notes
                    })
                # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –±—É—Ñ–µ—Ä
                table_buffer = []
                # –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π –æ–±—Ä–∞–∑–µ—Ü
                current_sample_name = para_text.split("–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞–∑—Ü–∞ :")[-1].strip()
                # –ò—â–µ–º –º–∞—Ä–∫—É —Å—Ç–∞–ª–∏ –≤ —ç—Ç–æ–º –∂–µ –ø–∞—Ä–∞–≥—Ä–∞—Ñ–µ
                steel_match = re.search(r"–º–∞—Ä–∫–µ —Å—Ç–∞–ª–∏:\s*([–ê-–Ø–∞-—è0-9–•—Ö]+)", para_text)
                if steel_match:
                    current_steel = steel_match.group(1).strip()
                else:
                    current_steel = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
            elif current_sample_name and "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π" in para_text:
                # –ü—Ä–æ—Å—Ç–æ –∑–∞–ø–æ–º–∏–Ω–∞–µ–º, —á—Ç–æ –¥–ª—è —ç—Ç–æ–≥–æ –æ–±—Ä–∞–∑—Ü–∞ –µ—Å—Ç—å –ø—Ä–∏–º–µ—á–∞–Ω–∏–µ
                # (–º—ã –¥–æ–±–∞–≤–∏–º –µ–≥–æ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ–±—Ä–∞–∑—Ü–∞)
                pass
        elif isinstance(block, Table):
            if current_sample_name:
                table_buffer.append(block)
                # –ï—Å–ª–∏ –Ω–∞–∫–æ–ø–∏–ª–∏ 2 —Ç–∞–±–ª–∏—Ü—ã ‚Äî –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º
                if len(table_buffer) == 2:
                    means1 = extract_means_from_table(table_buffer[0])
                    means2 = extract_means_from_table(table_buffer[1])
                    all_means = {**means1, **means2}
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø—Ä–∏–º–µ—á–∞–Ω–∏–µ –≤ –ø–∞—Ä–∞–≥—Ä–∞—Ñ–∞—Ö, –æ—Ç–Ω–æ—Å—è—â–∏—Ö—Å—è –∫ —ç—Ç–æ–º—É –æ–±—Ä–∞–∑—Ü—É
                    notes = ""
                    # –ü—Ä–æ—Å—Ç–æ–π —Å–ø–æ—Å–æ–±: –ø—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –ª–∏ —Ç–µ–∫—Å—Ç "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π" –≤ –ø–∞—Ä–∞–≥—Ä–∞—Ñ–µ —Å –∏–º–µ–Ω–µ–º –æ–±—Ä–∞–∑—Ü–∞
                    # –∏–ª–∏ –≤ —Å–ª–µ–¥—É—é—â–∏—Ö –ø–∞—Ä–∞–≥—Ä–∞—Ñ–∞—Ö –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±—Ä–∞–∑—Ü–∞
                    # –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã, –µ—Å–ª–∏ –≤ –ø–∞—Ä–∞–≥—Ä–∞—Ñ–µ —Å –∏–º–µ–Ω–µ–º –æ–±—Ä–∞–∑—Ü–∞ –µ—Å—Ç—å –ø—Ä–∏–º–µ—á–∞–Ω–∏–µ
                    if "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π" in current_sample_name:
                        notes = "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π"
                    else:
                        # –ú–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—É—é –ø—Ä–æ–≤–µ—Ä–∫—É, –Ω–æ –ø–æ–∫–∞ —Ç–∞–∫
                        pass
                    samples.append({
                        "name": current_sample_name,
                        "steel": current_steel,
                        "elements": all_means,
                        "notes": notes
                    })
                    # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±—Ä–∞–∑—Ü–∞
                    current_sample_name = None
                    current_steel = None
                    table_buffer = []

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±—Ä–∞–∑—Ü–∞
    if current_sample_name and len(table_buffer) >= 2:
        means1 = extract_means_from_table(table_buffer[0])
        means2 = extract_means_from_table(table_buffer[1])
        all_means = {**means1, **means2}
        notes = "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π" if "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π" in current_sample_name else ""
        samples.append({
            "name": current_sample_name,
            "steel": current_steel,
            "elements": all_means,
            "notes": notes
        })

    return samples

def evaluate_status(value, norm_min, norm_max):
    if norm_min is not None and value < norm_min:
        return "üî¥"
    if norm_max is not None and value > norm_max:
        return "üî¥"
    return ""

def format_value(val, elem):
    if elem in ["S", "P"]:
        return f"{val:.3f}".replace(".", ",")
    else:
        return f"{val:.2f}".replace(".", ",")

def format_norm(norm_min, norm_max):
    if norm_min is None:
        return f"‚â§{norm_max:.2f}".replace(".", ",")
    elif norm_max is None:
        return f"‚â•{norm_min:.2f}".replace(".", ",")
    else:
        return f"{norm_min:.2f}‚Äì{norm_max:.2f}".replace(".", ",")

# ================================
# –ì–µ–Ω–µ—Ä–∞—Ü–∏—è Word-–æ—Ç—á—ë—Ç–∞ –¥–ª—è –æ–¥–Ω–æ–π —Å—Ç–∞–ª–∏
# ================================
def create_word_report_for_steel(samples, steel):
    doc = Document()
    style = doc.styles['Normal']
    font = style.font
    font.name = 'Times New Roman'
    font.size = Pt(12)

    doc.add_heading(f'–û—Ç—á—ë—Ç –ø–æ —Ö–∏–º–∏—á–µ—Å–∫–æ–º—É —Å–æ—Å—Ç–∞–≤—É –º–µ—Ç–∞–ª–ª–∞ ‚Äî —Å—Ç–∞–ª—å {steel}', 0)
    doc.add_paragraph('–ò—Å—Ç–æ—á–Ω–∏–∫: –ü—Ä–æ—Ç–æ–∫–æ–ª ‚Ññ 46/10 –æ—Ç 02.10.2025, –û–ê–û ¬´–í–¢–ò¬ª')

    elements = ELEMENTS_BY_STEEL.get(steel, [])
    if not elements:
        doc.add_paragraph("–î–ª—è —ç—Ç–æ–π —Å—Ç–∞–ª–∏ –Ω–µ—Ç –Ω–æ—Ä–º–∞—Ç–∏–≤–æ–≤")
        return doc

    cols = ["–û–±—Ä–∞–∑–µ—Ü"] + elements
    table = doc.add_table(rows=1, cols=len(cols))
    table.style = 'Table Grid'

    # –ó–∞–≥–æ–ª–æ–≤–æ–∫
    for i, c in enumerate(cols):
        table.rows[0].cells[i].text = c
        table.rows[0].cells[i].paragraphs[0].runs[0].font.name = 'Times New Roman'

    # –î–∞–Ω–Ω—ã–µ
    for sample in samples:
        if sample["steel"] != steel:
            continue
        row = table.add_row().cells
        row[0].text = sample["name"]
        row[0].paragraphs[0].runs[0].font.name = 'Times New Roman'
        for j, elem in enumerate(elements, start=1):
            val = sample["elements"].get(elem)
            cell = row[j]
            if val is not None:
                txt = format_value(val, elem)
                cell.text = txt
                status = evaluate_status(val, *NORMS[steel][elem])
                if status == "üî¥":
                    shading = OxmlElement('w:shd')
                    shading.set(qn('w:fill'), 'ffcccc')
                    cell._element.get_or_add_tcPr().append(shading)
            else:
                cell.text = "‚Äì"
            cell.paragraphs[0].runs[0].font.name = 'Times New Roman'

    # –°—Ç—Ä–æ–∫–∞ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π
    req_row = table.add_row().cells
    req_row[0].text = f"–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –¢–£ 14-3–†-55-2001 [3] –¥–ª—è —Å—Ç–∞–ª–∏ –º–∞—Ä–∫–∏ {steel}"
    req_row[0].paragraphs[0].runs[0].font.name = 'Times New Roman'
    for j, elem in enumerate(elements, start=1):
        nmin, nmax = NORMS[steel][elem]
        req_row[j].text = format_norm(nmin, nmax)
        req_row[j].paragraphs[0].runs[0].font.name = 'Times New Roman'

    # –í—ã–≤–æ–¥—ã
    doc.add_heading('–í—ã–≤–æ–¥—ã', level=1)
    for s in samples:
        if s["steel"] != steel:
            continue
        doc.add_heading(s["name"], level=2)
        for elem in elements:
            val = s["elements"].get(elem)
            if val is not None:
                nmin, nmax = NORMS[steel][elem]
                status = evaluate_status(val, nmin, nmax)
                if status == "üî¥":
                    doc.add_paragraph(f"üî¥ {elem} = {format_value(val, elem)} ‚Äî –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–æ—Ä–º–µ ({format_norm(nmin, nmax)})")
                else:
                    doc.add_paragraph(f"‚úÖ {elem} = {format_value(val, elem)} ‚Äî —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–æ—Ä–º–µ")
        if s["notes"]:
            doc.add_paragraph(f"üìå –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: {s['notes']}")

    doc.add_heading('–õ–µ–≥–µ–Ω–¥–∞', level=1)
    doc.add_paragraph("üî¥ ‚Äî –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–æ—Ä–º–∞–º\n‚úÖ ‚Äî —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–æ—Ä–º–∞–º")

    return doc

# ================================
# Streamlit UI
# ================================
st.set_page_config(page_title="–ê–Ω–∞–ª–∏–∑ —Ö–∏–º—Å–æ—Å—Ç–∞–≤–∞", layout="wide")
st.title("–ê–Ω–∞–ª–∏–∑ —Ö–∏–º–∏—á–µ—Å–∫–æ–≥–æ —Å–æ—Å—Ç–∞–≤–∞ –º–µ—Ç–∞–ª–ª–∞")

uploaded_files = st.file_uploader("–ó–∞–≥—Ä—É–∑–∏—Ç–µ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã (.docx)", type=["docx"], accept_multiple_files=True)

if uploaded_files:
    all_samples = []
    for file in uploaded_files:
        try:
            samples = parse_protocol_docx(file)
            all_samples.extend(samples)
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞ {file.name}: {e}")

    if not all_samples:
        st.info("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∏ –æ–¥–∏–Ω —Ñ–∞–π–ª")
        st.stop()

    # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –æ–±—Ä–∞–∑—Ü—ã –ø–æ –º–∞—Ä–∫–∞–º —Å—Ç–∞–ª–µ–π
    steel_groups = {}
    for s in all_samples:
        steel = s["steel"]
        if steel not in steel_groups:
            steel_groups[steel] = []
        steel_groups[steel].append(s)

    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–∞–±–ª–∏—Ü—ã –ø–æ –∫–∞–∂–¥–æ–π —Å—Ç–∞–ª–∏
    for steel, group_samples in steel_groups.items():
        st.subheader(f"–°—Ç–∞–ª—å: {steel}")
        elements = ELEMENTS_BY_STEEL.get(steel, [])
        if not elements:
            st.warning("–î–ª—è —ç—Ç–æ–π —Å—Ç–∞–ª–∏ –Ω–µ—Ç –Ω–æ—Ä–º–∞—Ç–∏–≤–æ–≤")
            continue

        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        data = []
        for s in group_samples:
            row = {"–û–±—Ä–∞–∑–µ—Ü": s["name"]}
            for elem in elements:
                val = s["elements"].get(elem)
                row[elem] = format_value(val, elem) if val is not None else "‚Äì"
            data.append(row)

        df = pd.DataFrame(data)
        cols_order = ["–û–±—Ä–∞–∑–µ—Ü"] + elements
        df = df[cols_order]

        # HTML-—Ç–∞–±–ª–∏—Ü–∞
        html_rows = ["<tr>" + "".join(f"<th style='font-family: Times New Roman;'>{c}</th>" for c in cols_order) + "</tr>"]
        for _, r in df.iterrows():
            row_html = f"<td style='font-family: Times New Roman;'>{r['–û–±—Ä–∞–∑–µ—Ü']}</td>"
            for elem in elements:
                val_str = r[elem]
                if val_str == "‚Äì":
                    row_html += f'<td style="font-family: Times New Roman;">{val_str}</td>'
                else:
                    try:
                        val_num = float(val_str.replace(",", "."))
                        nmin, nmax = NORMS[steel][elem]
                        status = evaluate_status(val_num, nmin, nmax)
                        if status == "üî¥":
                            row_html += f'<td style="background-color:#ffcccc; font-family: Times New Roman;">{val_str}</td>'
                        else:
                            row_html += f'<td style="font-family: Times New Roman;">{val_str}</td>'
                    except:
                        row_html += f'<td style="font-family: Times New Roman;">{val_str}</td>'
            html_rows.append("<tr>" + row_html + "</tr>")

        # –°—Ç—Ä–æ–∫–∞ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π
        req_cells = [f"–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –¢–£ 14-3–†-55-2001 [3] –¥–ª—è —Å—Ç–∞–ª–∏ –º–∞—Ä–∫–∏ {steel}"]
        for elem in elements:
            nmin, nmax = NORMS[steel][elem]
            req_cells.append(format_norm(nmin, nmax))
        req_row = "<tr>" + "".join(f"<td style='font-family: Times New Roman;'>{c}</td>" for c in req_cells) + "</tr>"
        html_rows.append(req_row)

        html_table = f'<table border="1" style="border-collapse:collapse; font-family: Times New Roman;">{"".join(html_rows)}</table>'
        st.markdown("##### –°–≤–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ (–∫–æ–ø–∏—Ä—É–π—Ç–µ –≤ Word):")
        st.markdown(html_table, unsafe_allow_html=True)

        # –ö–Ω–æ–ø–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞
        if st.button(f"üì• –°–∫–∞—á–∞—Ç—å –æ—Ç—á—ë—Ç –¥–ª—è —Å—Ç–∞–ª–∏ {steel}", key=f"download_{steel}"):
            doc = create_word_report_for_steel(group_samples, steel)
            bio = io.BytesIO()
            doc.save(bio)
            st.download_button(
                label=f"–°–∫–∞—á–∞—Ç—å –æ—Ç—á—ë—Ç_{steel}.docx",
                data=bio.getvalue(),
                file_name=f"–û—Ç—á—ë—Ç_—Ö–∏–º—Å–æ—Å—Ç–∞–≤_{steel}.docx",
                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            )

    # –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑
    st.subheader("–î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑")
    for s in all_samples:
        with st.expander(f"üîç {s['name']} ({s['steel']})"):
            elements = ELEMENTS_BY_STEEL.get(s["steel"], [])
            for elem in elements:
                val = s["elements"].get(elem)
                if val is not None:
                    nmin, nmax = NORMS[s["steel"]][elem]
                    status = evaluate_status(val, nmin, nmax)
                    if status == "üî¥":
                        st.error(f"{elem} = {format_value(val, elem)} ‚Äî –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–æ—Ä–º–µ ({format_norm(nmin, nmax)})")
                    else:
                        st.success(f"{elem} = {format_value(val, elem)} ‚Äî —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–æ—Ä–º–µ")
            if s["notes"]:
                st.info(f"üìå –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: {s['notes']}")

else:
    st.info("–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª—ã –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤ –≤ —Ñ–æ—Ä–º–∞—Ç–µ .docx")
