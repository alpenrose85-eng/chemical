import streamlit as st
import pandas as pd
from docx import Document
import re
import io
from docx.oxml.ns import qn
from docx.oxml import OxmlElement
from docx.shared import Pt

# –ù–æ—Ä–º—ã –¥–ª—è —Å—Ç–∞–ª–∏ 12–•1–ú–§ –ø–æ –¢–£ 14-3–†-55-2001
NORMS = {
    "C": (0.10, 0.15),
    "Si": (0.17, 0.27),
    "Mn": (0.40, 0.70),
    "Cr": (0.90, 1.20),
    "Ni": (None, 0.25),
    "Mo": (0.25, 0.35),
    "V": (0.15, 0.30),
    "Cu": (None, 0.20),   # –º–µ–¥—å ‚Äî –¥–æ —Å–æ—Ç—ã—Ö
    "S": (None, 0.025),
    "P": (None, 0.025)
}

# –ü–æ—Ä—è–¥–æ–∫ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ –∏—Ç–æ–≥–æ–≤–æ–π —Ç–∞–±–ª–∏—Ü–µ
ELEMENTS = ["C", "Si", "Mn", "Cr", "Ni", "Mo", "V", "Cu", "S", "P"]

def parse_protocol_docx(file):
    doc = Document(file)
    full_text = "\n".join([p.text for p in doc.paragraphs])
    blocks = re.split(r"–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –æ–±—Ä–∞–∑—Ü–∞\s*:", full_text)[1:]
    tables = doc.tables
    samples = []

    for i, block in enumerate(blocks):
        lines = [line.strip() for line in block.split("\n") if line.strip()]
        if not lines:
            continue
        sample_name = lines[0]

        # –ò–∑–≤–ª–µ–∫–∞–µ–º –º–∞—Ä–∫—É —Å—Ç–∞–ª–∏: "12–•1–ú–§"
        steel_match = re.search(r"–º–∞—Ä–∫–µ —Å—Ç–∞–ª–∏:\s*([–ê-–Ø–∞-—è0-9–•—Ö]+)", block)
        steel = steel_match.group(1).strip() if steel_match else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"

        notes = "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π" if "—Å —É—á–µ—Ç–æ–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–π" in block else ""

        # –ë–µ—Ä—ë–º 2 —Ç–∞–±–ª–∏—Ü—ã –Ω–∞ –æ–±—Ä–∞–∑–µ—Ü
        if i * 2 + 1 >= len(tables):
            break

        table1 = tables[i * 2]
        table2 = tables[i * 2 + 1]

        def extract_means(table):
            headers = []
            for cell in table.rows[0].cells[1:]:
                h = cell.text.strip().replace("\n", "").replace("%", "").strip()
                if h:
                    headers.append(h)
            for row in table.rows:
                if row.cells[0].text.strip() == "–°—Ä–µ–¥–Ω–µ–µ:":
                    values = {}
                    for j, elem in enumerate(headers):
                        if j + 1 < len(row.cells):
                            try:
                                val = float(row.cells[j + 1].text.replace(",", ".").strip())
                                values[elem] = val
                            except:
                                pass
                    return values
            return {}

        means1 = extract_means(table1)
        means2 = extract_means(table2)
        all_means = {**means1, **means2}

        samples.append({
            "name": sample_name,
            "steel": steel,
            "elements": all_means,
            "notes": notes
        })

    return samples

def evaluate_status(value, norm_min, norm_max):
    if norm_min is not None and value < norm_min:
        return "üî¥"
    if norm_max is not None and value > norm_max:
        return "üî¥"
    return ""

def format_value(val, elem):
    if elem in ["S", "P"]:
        return f"{val:.3f}".replace(".", ",")
    else:
        return f"{val:.2f}".replace(".", ",")

def format_norm(norm_min, norm_max):
    if norm_min is None:
        return f"‚â§{norm_max:.2f}".replace(".", ",")
    elif norm_max is None:
        return f"‚â•{norm_min:.2f}".replace(".", ",")
    else:
        return f"{norm_min:.2f}‚Äì{norm_max:.2f}".replace(".", ",")

# ================================
# –ì–µ–Ω–µ—Ä–∞—Ü–∏—è Word-–æ—Ç—á—ë—Ç–∞
# ================================
def create_word_report(samples):
    doc = Document()
    style = doc.styles['Normal']
    font = style.font
    font.name = 'Times New Roman'
    font.size = Pt(12)

    doc.add_heading('–û—Ç—á—ë—Ç –ø–æ —Ö–∏–º–∏—á–µ—Å–∫–æ–º—É —Å–æ—Å—Ç–∞–≤—É –º–µ—Ç–∞–ª–ª–∞', 0)
    doc.add_paragraph('–ò—Å—Ç–æ—á–Ω–∏–∫: –ü—Ä–æ—Ç–æ–∫–æ–ª ‚Ññ 27/05 –æ—Ç 26.05.2025, –û–ê–û ¬´–í–¢–ò¬ª')

    cols = ["–û–±—Ä–∞–∑–µ—Ü"] + ELEMENTS
    table = doc.add_table(rows=1, cols=len(cols))
    table.style = 'Table Grid'

    # –ó–∞–≥–æ–ª–æ–≤–æ–∫
    for i, c in enumerate(cols):
        table.rows[0].cells[i].text = c
        table.rows[0].cells[i].paragraphs[0].runs[0].font.name = 'Times New Roman'

    # –î–∞–Ω–Ω—ã–µ
    for sample in samples:
        row = table.add_row().cells
        row[0].text = sample["name"]
        for j, elem in enumerate(ELEMENTS, start=1):
            val = sample["elements"].get(elem)
            cell = row[j]
            if val is not None:
                txt = format_value(val, elem)
                cell.text = txt
                status = evaluate_status(val, *NORMS[elem])
                if status == "üî¥":
                    shading = OxmlElement('w:shd')
                    shading.set(qn('w:fill'), 'ffcccc')
                    cell._element.get_or_add_tcPr().append(shading)
            else:
                cell.text = "‚Äì"
            cell.paragraphs[0].runs[0].font.name = 'Times New Roman'

    # –°—Ç—Ä–æ–∫–∞ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π
    req_row = table.add_row().cells
    req_row[0].text = "–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –¢–£ 14-3–†-55-2001 [3] –¥–ª—è —Å—Ç–∞–ª–∏ –º–∞—Ä–∫–∏ 12–•1–ú–§"
    req_row[0].paragraphs[0].runs[0].font.name = 'Times New Roman'
    for j, elem in enumerate(ELEMENTS, start=1):
        req_row[j].text = format_norm(*NORMS[elem])
        req_row[j].paragraphs[0].runs[0].font.name = 'Times New Roman'

    # –í—ã–≤–æ–¥—ã
    doc.add_heading('–í—ã–≤–æ–¥—ã', level=1)
    for s in samples:
        doc.add_heading(s["name"], level=2)
        for elem in ELEMENTS:
            val = s["elements"].get(elem)
            if val is not None:
                nmin, nmax = NORMS[elem]
                status = evaluate_status(val, nmin, nmax)
                if status == "üî¥":
                    doc.add_paragraph(f"üî¥ {elem} = {format_value(val, elem)} ‚Äî –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–æ—Ä–º–µ ({format_norm(nmin, nmax)})")
                else:
                    doc.add_paragraph(f"‚úÖ {elem} = {format_value(val, elem)} ‚Äî —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–æ—Ä–º–µ")
        if s["notes"]:
            doc.add_paragraph(f"üìå –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: {s['notes']}")

    doc.add_heading('–õ–µ–≥–µ–Ω–¥–∞', level=1)
    doc.add_paragraph("üî¥ ‚Äî –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–æ—Ä–º–∞–º\n‚úÖ ‚Äî —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –Ω–æ—Ä–º–∞–º")

    return doc

# ================================
# Streamlit UI
# ================================
st.set_page_config(page_title="–ê–Ω–∞–ª–∏–∑ —Ö–∏–º—Å–æ—Å—Ç–∞–≤–∞", layout="wide")
st.title("–ê–Ω–∞–ª–∏–∑ —Ö–∏–º–∏—á–µ—Å–∫–æ–≥–æ —Å–æ—Å—Ç–∞–≤–∞ –º–µ—Ç–∞–ª–ª–∞")

uploaded = st.file_uploader("–ó–∞–≥—Ä—É–∑–∏—Ç–µ –ø—Ä–æ—Ç–æ–∫–æ–ª (.docx)", type=["docx"])

if uploaded:
    try:
        samples = parse_protocol_docx(uploaded)
        st.success(f"–ó–∞–≥—Ä—É–∂–µ–Ω–æ –æ–±—Ä–∞–∑—Ü–æ–≤: {len(samples)}")

        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
        data = []
        for s in samples:
            row = {"–û–±—Ä–∞–∑–µ—Ü": s["name"]}
            for elem in ELEMENTS:
                val = s["elements"].get(elem)
                row[elem] = format_value(val, elem) if val is not None else "‚Äì"
            data.append(row)

        df = pd.DataFrame(data)
        cols_order = ["–û–±—Ä–∞–∑–µ—Ü"] + ELEMENTS
        df = df[cols_order]

        # HTML-—Ç–∞–±–ª–∏—Ü–∞
        html_rows = ["<tr>" + "".join(f"<th style='font-family: Times New Roman;'>{c}</th>" for c in cols_order) + "</tr>"]
        for _, r in df.iterrows():
            row_html = f"<td style='font-family: Times New Roman;'>{r['–û–±—Ä–∞–∑–µ—Ü']}</td>"
            for elem in ELEMENTS:
                val_str = r[elem]
                if val_str == "‚Äì":
                    row_html += f'<td style="font-family: Times New Roman;">{val_str}</td>'
                else:
                    try:
                        val_num = float(val_str.replace(",", "."))
                        status = evaluate_status(val_num, *NORMS[elem])
                        if status == "üî¥":
                            row_html += f'<td style="background-color:#ffcccc; font-family: Times New Roman;">{val_str}</td>'
                        else:
                            row_html += f'<td style="font-family: Times New Roman;">{val_str}</td>'
                    except:
                        row_html += f'<td style="font-family: Times New Roman;">{val_str}</td>'
            html_rows.append("<tr>" + row_html + "</tr>")

        # –°—Ç—Ä–æ–∫–∞ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π
        req_cells = ["–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è –¢–£ 14-3–†-55-2001 [3] –¥–ª—è —Å—Ç–∞–ª–∏ –º–∞—Ä–∫–∏ 12–•1–ú–§"]
        for elem in ELEMENTS:
            req_cells.append(format_norm(*NORMS[elem]))
        req_row = "<tr>" + "".join(f"<td style='font-family: Times New Roman;'>{c}</td>" for c in req_cells) + "</tr>"
        html_rows.append(req_row)

        html_table = f'<table border="1" style="border-collapse:collapse; font-family: Times New Roman;">{"".join(html_rows)}</table>'
        st.markdown("### –°–≤–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ (–∫–æ–ø–∏—Ä—É–π—Ç–µ –≤ Word):")
        st.markdown(html_table, unsafe_allow_html=True)

        # –≠–∫—Å–ø–æ—Ä—Ç
        if st.button("üì• –°–∫–∞—á–∞—Ç—å –æ—Ç—á—ë—Ç –≤ Word"):
            doc = create_word_report(samples)
            bio = io.BytesIO()
            doc.save(bio)
            st.download_button(
                label="–°–∫–∞—á–∞—Ç—å –æ—Ç—á—ë—Ç.docx",
                data=bio.getvalue(),
                file_name="–û—Ç—á—ë—Ç_—Ö–∏–º—Å–æ—Å—Ç–∞–≤_12–•1–ú–§.docx",
                mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            )

        # –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑
        st.subheader("–î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑")
        for s in samples:
            with st.expander(f"üîç {s['name']}"):
                for elem in ELEMENTS:
                    val = s["elements"].get(elem)
                    if val is not None:
                        nmin, nmax = NORMS[elem]
                        status = evaluate_status(val, nmin, nmax)
                        if status == "üî¥":
                            st.error(f"{elem} = {format_value(val, elem)} ‚Äî –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–æ—Ä–º–µ ({format_norm(nmin, nmax)})")
                        else:
                            st.success(f"{elem} = {format_value(val, elem)} ‚Äî —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –Ω–æ—Ä–º–µ")
                if s["notes"]:
                    st.info(f"üìå –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: {s['notes']}")

    except Exception as e:
        st.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞: {e}")
else:
    st.info("–ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ñ–∞–π–ª –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ .docx")
